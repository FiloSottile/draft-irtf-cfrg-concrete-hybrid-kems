



Crypto Forum                                                 D. Connolly
Internet-Draft                                                 SandboxAQ
Intended status: Informational                              18 June 2025
Expires: 20 December 2025


           Concrete Hybrid PQ/T Key Encapsulation Mechanisms
              draft-irtf-cfrg-concrete-hybrid-kems-latest

Abstract

   PQ/T Hybrid Key Encapsulation Mechanisms (KEMs) combine "post-
   quantum" cryptographic algorithms, which are safe from attack by a
   quantum computer, with "traditional" algorithms, which are not.  CFRG
   has developed a general framework for creating hybrid KEMs.  In this
   document, we define concrete instantiations of this framework to
   illustrate certain properties of the framework and simplify
   implementors' choices.

About This Document

   This note is to be removed before publishing as an RFC.

   The latest revision of this draft can be found at
   https://cfrg.github.io/draft-irtf-cfrg-concrete-hybrid-kems/draft-
   irtf-cfrg-concrete-hybrid-kems.html.  Status information for this
   document may be found at https://datatracker.ietf.org/doc/draft-irtf-
   cfrg-concrete-hybrid-kems/.

   Discussion of this document takes place on the Crypto Forum Research
   Group mailing list (mailto:cfrg@ietf.org), which is archived at
   https://mailarchive.ietf.org/arch/search/?email_list=cfrg.  Subscribe
   at https://www.ietf.org/mailman/listinfo/cfrg/.

   Source for this draft and an issue tracker can be found at
   https://github.com/cfrg/draft-irtf-cfrg-concrete-hybrid-kems.

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at https://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on 20 December 2025.

Copyright Notice

   Copyright (c) 2025 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents (https://trustee.ietf.org/
   license-info) in effect on the date of publication of this document.
   Please review these documents carefully, as they describe your rights
   and restrictions with respect to this document.

Table of Contents

   1.  Introduction
   2.  Conventions and Definitions
   3.  Concrete Nominal Group and KEM Instances
     3.1.  Nominal Groups
       3.1.1.  P-256 Nominal Group
       3.1.2.  P-384 Nominal Group
       3.1.3.  Curve25519 Nominal Group
     3.2.  Concrete KEM Instances
       3.2.1.  ML-KEM-768
       3.2.2.  ML-KEM-1024
   4.  Concrete Hybrid KEM Instances
     4.1.  HNN3
     4.2.  HNX
     4.3.  HNN5
       4.3.1.  Security properties
   5.  Security Considerations
   6.  IANA Considerations
   7.  References
     7.1.  Normative References
     7.2.  Informative References
   Acknowledgments
   Author's Address

1.  Introduction

   PQ/T Hybrid Key Encapsulation Mechanisms (KEMs) combine "post-
   quantum" cryptographic algorithms, which are safe from attack by a
   quantum computer, with "traditional" algorithms, which are not.  Such
   KEMs are secure against a quantum attacker as long as the PQ
   algorithm is secure, and remain secure against traditional attackers
   even if the PQ algorithm is not secure.

   [HYBRID-KEMS] defines a general framework for creating hybrid KEMs.
   It includes multiple specific mechanisms for combining a PQ algorithm
   with a traditional algorithm, with different performance properties
   and security requirements for the underlying algorithms.

   In this document, we describe instances of these different specific
   combiners, with specific choices for the underlying algorithms.  The
   choices described here illustrate the security analysis required to
   make choices that meet the requirements of the general framework, and
   can serve as a baseline for application designers.  We also provide
   test vectors for these instances so that implementors can verify the
   correctness of their implementations.

2.  Conventions and Definitions

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
   "OPTIONAL" in this document are to be interpreted as described in
   BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all
   capitals, as shown here.

   We make extensive use of the terminology in [HYBRID-KEMS].

3.  Concrete Nominal Group and KEM Instances

   This document introduces concrete hybrid KEM instances that in turn
   depend on concrete KEM and nominal group instances.  This section
   introduces the nominal groups and KEM instances used for concrete
   hybrid KEM instances, specified in line with the abstraction from
   [HYBRID-KEMS].  Section 3.1 defines the concrete nominal groups, and
   Section 3.2 defines the nominal KEMs.

3.1.  Nominal Groups

   This section specifies concrete nominal groups that implement the
   abstraction in [HYBRID-KEMS].  It includes groups based on the NIST
   curves P-256 and P-384 [FIPS186], as well as a group based on
   Curve25519 from [RFC7748]

3.1.1.  P-256 Nominal Group

   The following functions for the P-256 nominal group are defined:

   *  Exp(p, x) -> q: This function computes scalar multiplication
      between the input element (or point) p and the scalar x [FIPS186].

   *  RandomScalar(seed) -> k: Implemented by converting seed to an
      integer using OS2IP, and then reducing the resulting integer
      modulo the group order.

   *  ElementToSharedSecret(P) -> ss: Implemented using the compressed
      Elliptic-Curve-Point-to-Octet-String method according to [SEC1]
      with input P, yielding a Nelem-byte output.  Additionally, this
      function validates that the input element is not the group
      identity element.  Finally, this function outputs the encoding the
      X coordinate of the elliptic curve point corresponding to P to a
      little-endian Nss-byte string.

   The following constants are also defined.

   *  Nseed: 48

   *  Nscalar: 32

   *  Nelem: 33

   *  Nss: 32

3.1.2.  P-384 Nominal Group

   The following functions for the P-384 nominal group are defined:

   *  Exp(p, x) -> q: This function computes scalar multiplication
      between the input element (or point) p and the scalar x [FIPS186].

   *  RandomScalar(seed) -> k: Implemented by converting seed to an
      integer using OS2IP, and then reducing the resulting integer
      modulo the group order.

   *  ElementToSharedSecret(P) -> ss: Implemented using the compressed
      Elliptic-Curve-Point-to-Octet-String method according to [SEC1]
      with input P, yielding a Nelem-byte output.  Additionally, this
      function validates that the input element is not the group
      identity element.  Finally, this function outputs the encoding the
      X coordinate of the elliptic curve point corresponding to P to a
      little-endian Nss-byte string.

   The following constants are also defined.

   *  Nseed: 72

   *  Nscalar: 48

   *  Nelem: 48

   *  Nss: 32

3.1.3.  Curve25519 Nominal Group

   The following functions for the Curve25519 nominal group are defined:

   *  Exp(p, x) -> q: Implemented by X25519(x, p) from [RFC7748].

   *  RandomScalar(seed) -> k: Implemented by sampling and outputting 32
      random bytes from a cryptographically secure pseudorandom number
      generator.

   *  ElementToSharedSecret(P) -> ss: Implemented by the identity
      function, i.e., by outputting P.

   The following constants are also defined.

   *  Nseed: 32

   *  Nscalar: 32

   *  Nelem: 32

   *  Nss: 32

3.2.  Concrete KEM Instances

   This section specifies concrete KEM instances that implement the KEM
   abstraction from [HYBRID-KEMS].  It focuses solely on ML-KEM as
   specified in [FIPS203].

3.2.1.  ML-KEM-768

   The ML-KEM-768 nominal KEM implements the KEM abstraction from
   [HYBRID-KEMS] with the following functions:

   *  GenerateKeyPair() -> (ek, dk): Implemented as KeyGen in
      Section 7.1 of [FIPS203].

   *  DeriveKeyPair(seed) -> (ek, dk): Implemented as
      KeyGen_internal(seed[0:32], seed[32:64]), where KeyGen_internal is
      defined in Section 6 of [FIPS203].

   *  Encaps(ek) -> (ct, ss): Implemented as Encaps in Section 7.2 of
      [FIPS203].

   *  Decaps(dk, ct) -> ss: Implemented as Encaps in Section 7.3 of
      [FIPS203].

   *  EncapsDerand(ek, randomness) -> (ct, shared_secret): [[TODO:
      citeme]

   The following constants are also defined:

   *  Nseed: 64

   *  Nek: 1216

   *  Ndk: 32

   *  Nct: 1120

   *  Nss: 32

3.2.2.  ML-KEM-1024

   The ML-KEM-1024 nominal KEM implements the KEM abstraction from
   [HYBRID-KEMS] with the following functions:

   *  GenerateKeyPair() -> (ek, dk): Implemented as KeyGen in
      Section 7.1 of [FIPS203].

   *  DeriveKeyPair(seed) -> (ek, dk): Implemented as
      KeyGen_internal(seed[0:32], seed[32:64]), where KeyGen_internal is
      defined in Section 6 of [FIPS203].

   *  Encaps(ek) -> (ct, ss): Implemented as Encaps in Section 7.2 of
      [FIPS203].

   *  Decaps(dk, ct) -> ss: Implemented as Encaps in Section 7.3 of
      [FIPS203].

   *  EncapsDerand(ek, randomness) -> (ct, shared_secret): [[TODO:
      citeme]

   The following constants are also defined:

   *  Nseed: 64

   *  Nek: 1629

   *  Ndk: 32

   *  Nct: 1629

   *  Nss: 32

4.  Concrete Hybrid KEM Instances

   This section instantiates three concrete KEMs:

   1.  HNN3 Section 4.1: A hybrid KEM composing ML-KEM-768 and P-256
       using the HashTraditionalOnly combiner with SHA3-256 as the
       Combine KDF and SHAKE256 as the Expand KDF.

   2.  HNX Section 4.2: A hybrid KEM composing ML-KEM-768 and Curve25519
       using the HashTraditionalOnly combiner with SHA3-256 as the
       Combine KDF and SHAKE256 as the Expand KDF.  This variant is
       identical to X-Wing [XWING-SPEC].

   3.  HNN5 Section 4.3: A hybrid KEM composing ML-KEM-1024 and P-384
       using the HashTraditionalOnly combiner with SHA3-256 as the
       Combine KDF and SHAKE256 as the Expand KDF.

   Each instance specifies the PQ and traditional KEMs being combined,
   the combiner construction from [HYBRID-KEMS], the label to use for
   domain separation in the combiner function, as well as the XOF and
   KDF functions to use throughout.

4.1.  HNN3

   This hybrid KEM is heavily based on [XWING], using the
   HashTraditionalOnly combiner from [HYBRID-KEMS].  In particular, it
   has the same exact design but uses P-256 instead of X25519 as the the
   traditional component of the algorithm.  It has the following
   parameters.

   *  Group_T: P-256 Section 3.1.1

   *  KEM_PQ: ML-KEM-768 Section 3.2.1

   *  Expand: SHAKE-256 [FIPS202]

   *  Combine: SHA3-256 [FIPS202]

   *  Label - HNN3

   The following constants for the hybrid KEM are also defined:

   *  Nseed: 32

   *  Nek: 1217

   *  Ndk: 32

   *  Nct: 1121

   *  Nss: 32

   With these parameters in place, this hybrid KEM is defined as
   follows:

   def GenerateKeyPair():
       seed = random(Nseed)
       return DeriveKeyPair(seed)

   def DeriveKeyPair(seed):
       seed_full = Expand(seed)
       (seed_T, seed_PQ) = split(Group_T.Nseed, KEM_PQ.Nseed, seed)

       dk_T = Group_T.RandomScalar(seed_T)
       ek_T = Group_T.Exp(Group_T.g, dk_T)
       (ek_PQ, dk_PQ) = KEM_PQ.DeriveKeyPair(seed_PQ)

       ek_H = concat(ek_T, ek_PQ)
       dk_H = concat(dk_T, dk_PQ)
       return (ek_H, dk_H)

   def Encaps(ek):
       (ek_T, ek_PQ) = split(Group_T.Nek, KEM_PQ.Nek, ek)

       sk_E = Group_T.RandomScalar(random(GroupT.nseed))
       ct_T = Group_T.Exp(GroupT.g, sk_E)
       ss_T = Group_T.ElementToSharedSecret(Group_T.Exp(ek_T, sk_E))
       (ss_PQ, ct_PQ) = KEM_PQ.Encap(ek_PQ)

       ss_H = Combine(concat(ss_PQ, ss_T, ct_T, ek_T, Label))
       ct_H = concat(ct_T, ct_PQ)
       return (ss_H, ct_H)

   def Decaps(dk, ct):
       (dk_T, dk_PQ) = split(Group_T.Ndk, KEM_PQ.Ndk, dk)
       (ct_T, ct_PQ) = split(Group_T.Nct, KEM_PQ.Nct, ct)

       ek_T = Group_T.ToEncaps(dk_T)
       ek_PQ = KEM_PQ.ToEncaps(dk_PQ)

       ss_T = Group_T.ElementToSharedSecret(Group_T.Exp(ct_T, dk_T))
       ss_PQ = KEM_PQ.Decap(dk_PQ, ct_PQ)

       ss_H = Combine(concat(ss_PQ, ss_T, ct_T, ek_T, Label))
       return ss_H

4.2.  HNX

   This hybrid KEM is identical to X-Wing [XWING-SPEC].  It has the
   following parameters.

   *  Group_T: Curve25519 Section 3.1.3

   *  KEM_PQ: ML-KEM-768 Section 3.2.1

   *  Expand: SHAKE-256 [FIPS202]

   *  Combine: SHA3-256 [FIPS202]

   *  Label - \.//^\

   The following constants for the hybrid KEM are also defined:

   *  Nseed: 32

   *  Nek: 1216

   *  Ndk: 32

   *  Nct: 1120

   *  Nss: 32

   With these parameters in place, this hybrid KEM is defined as
   follows:

   def GenerateKeyPair():
       seed = random(Nseed)
       return DeriveKeyPair(seed)

   def DeriveKeyPair(seed):
       seed_full = Expand(seed)
       (seed_T, seed_PQ) = split(Group_T.Nseed, KEM_PQ.Nseed, seed)

       dk_T = Group_T.RandomScalar(seed_T)
       ek_T = Group_T.Exp(Group_T.g, dk_T)
       (ek_PQ, dk_PQ) = KEM_PQ.DeriveKeyPair(seed_PQ)

       ek_H = concat(ek_T, ek_PQ)
       dk_H = concat(dk_T, dk_PQ)
       return (ek_H, dk_H)

   def Encaps(ek):
       (ek_T, ek_PQ) = split(Group_T.Nek, KEM_PQ.Nek, ek)

       sk_E = Group_T.RandomScalar(random(GroupT.nseed))
       ct_T = Group_T.Exp(GroupT.g, sk_E)
       ss_T = Group_T.ElementToSharedSecret(Group_T.Exp(ek_T, sk_E))
       (ss_PQ, ct_PQ) = KEM_PQ.Encap(ek_PQ)

       ss_H = Combine(concat(ss_PQ, ss_T, ct_T, ek_T, Label))
       ct_H = concat(ct_T, ct_PQ)
       return (ss_H, ct_H)

   def Decaps(dk, ct):
       (dk_T, dk_PQ) = split(Group_T.Ndk, KEM_PQ.Ndk, dk)
       (ct_T, ct_PQ) = split(Group_T.Nct, KEM_PQ.Nct, ct)

       ek_T = Group_T.ToEncaps(dk_T)
       ek_PQ = KEM_PQ.ToEncaps(dk_PQ)

       ss_T = Group_T.ElementToSharedSecret(Group_T.Exp(ct_T, dk_T))
       ss_PQ = KEM_PQ.Decap(dk_PQ, ct_PQ)

       ss_H = Combine(concat(ss_PQ, ss_T, ct_T, ek_T, Label))
       return ss_H

4.3.  HNN5

   HNN5 has the following parameters.

   *  Group_T: P-384 Section 3.1.2

   *  KEM_PQ: ML-KEM-1024 Section 3.2.2

   *  Expand: SHAKE-256 [FIPS202]

   *  Combine: HKDF-SHA-256 [RFC5869]

   *  Label - HNN3

   The following constants for the hybrid KEM are also defined:

   *  Nseed: 32

   *  Nek: 1629

   *  Ndk: 32

   *  Nct: 1629

   *  Nss: 32

   With these parameters in place, this hybrid KEM is defined as
   follows:

   def GenerateKeyPair():
       seed = random(Nseed)
       return DeriveKeyPair(seed)

   def DeriveKeyPair(seed):
       seed_full = Expand(seed)
       (seed_T, seed_PQ) = split(Group_T.Nseed, KEM_PQ.Nseed, seed)

       dk_T = Group_T.RandomScalar(seed_T))
       ek_T = Group_T.Exp(Group_T.g, dk_T)
       (ek_PQ, dk_PQ) = KEM_PQ.DeriveKeyPair(seed_PQ)

       ek_H = concat(ek_T, ek_PQ)
       dk_H = concat(dk_T, dk_PQ)
       return (ek_H, dk_H)

   def Encaps(ek):
       (ek_T, ek_PQ) = split(Group_T.Nek, KEM_PQ.Nek, ek)

       sk_E = Group_T.RandomScalar(random(GroupT.nseed))
       ct_T = Group_T.Exp(GroupT.g, sk_E)
       ss_T = Group_T.ElementToSharedSecret(Group_T.Exp(ek_T, sk_E))
       (ss_PQ, ct_PQ) = KEM_PQ.Encap(ek_PQ)

       ss_H = Combine(concat(ss_PQ, ss_T, ct_T, ek_T, Label))
       ct_H = concat(ct_T, ct_PQ)
       return (ss_H, ct_H)

   def Decaps(dk, ct):
       (dk_T, dk_PQ) = split(Group_T.Ndk, KEM_PQ.Ndk, dk)
       (ct_T, ct_PQ) = split(Group_T.Nct, KEM_PQ.Nct, ct)

       ek_T = Group_T.ToEncaps(dk_T)
       ek_PQ = KEM_PQ.ToEncaps(dk_PQ)

       ss_T = Group_T.ElementToSharedSecret(Group_T.Exp(ct_T, dk_T))
       ss_PQ = KEM_PQ.Decap(dk_PQ, ct_PQ)

       ss_H = Combine(concat(ss_PQ, ss_T, ct_T, ek_T, Label))
       return ss_H

4.3.1.  Security properties

   The inlined DH-KEM is instantiated over the elliptic curve group
   P-384: as shown in [CDM23], this gives the traditional KEM maximum
   binding properties (MAL-BIND-K-CT, MAL-BIND-K-PK).

   ML-KEM-1024 as standardized in [FIPS203], when using the 64-byte seed
   key format as is here, provides MAL-BIND-K-CT security and LEAK-BIND-
   K-PK security, as demonstrated in [SCHMIEG2024].

   Therefore this concrete instance provides MAL-BIND-K-PK and MAL-BIND-
   K-CT security.

   This implies via [KSMW2024] that this instance also satisfies

   *  MAL-BIND-K,CT-PK

   *  MAL-BIND-K,PK-CT

   *  LEAK-BIND-K-PK

   *  LEAK-BIND-K-CT

   *  LEAK-BIND-K,CT-PK

   *  LEAK-BIND-K,PK-CT

   *  HON-BIND-K-PK

   *  HON-BIND-K-CT

   *  HON-BIND-K,CT-PK

   *  HON-BIND-K,PK-CT

5.  Security Considerations

   [[TODO: writeme]]

6.  IANA Considerations

   This document has no IANA actions.

7.  References

7.1.  Normative References

   [FIPS202]  "SHA-3 standard :: permutation-based hash and extendable-
              output functions", National Institute of Standards and
              Technology (U.S.), DOI 10.6028/nist.fips.202, 2015,
              <https://doi.org/10.6028/nist.fips.202>.

   [FIPS203]  "Module-lattice-based key-encapsulation mechanism
              standard", National Institute of Standards and Technology
              (U.S.), DOI 10.6028/nist.fips.203, August 2024,
              <https://doi.org/10.6028/nist.fips.203>.

   [HYBRID-KEMS]
              Connolly, D., "Hybrid PQ/T Key Encapsulation Mechanisms",
              Work in Progress, Internet-Draft, draft-irtf-cfrg-hybrid-
              kems-03, 25 February 2025,
              <https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-
              hybrid-kems-03>.

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <https://www.rfc-editor.org/rfc/rfc2119>.

   [RFC5869]  Krawczyk, H. and P. Eronen, "HMAC-based Extract-and-Expand
              Key Derivation Function (HKDF)", RFC 5869,
              DOI 10.17487/RFC5869, May 2010,
              <https://www.rfc-editor.org/rfc/rfc5869>.

   [RFC7748]  Langley, A., Hamburg, M., and S. Turner, "Elliptic Curves
              for Security", RFC 7748, DOI 10.17487/RFC7748, January
              2016, <https://www.rfc-editor.org/rfc/rfc7748>.

   [RFC8174]  Leiba, B., "Ambiguity of Uppercase vs Lowercase in RFC
              2119 Key Words", BCP 14, RFC 8174, DOI 10.17487/RFC8174,
              May 2017, <https://www.rfc-editor.org/rfc/rfc8174>.

7.2.  Informative References

   [ANSIX9.62]
              ANS, "Public Key Cryptography for the Financial Services
              Industry: the Elliptic Curve Digital Signature Algorithm
              (ECDSA)", ANS X9.62-2005, November 2005.

   [CDM23]    Cremers, C., Dax, A., and N. Medinger, "Keeping Up with
              the KEMs: Stronger Security Notions for KEMs and automated
              analysis of KEM-based protocols", 2023,
              <https://eprint.iacr.org/2023/1933.pdf>.

   [FIPS186]  "Digital Signature Standard (DSS)", National Institute of
              Standards and Technology (U.S.),
              DOI 10.6028/nist.fips.186-5, February 2023,
              <https://doi.org/10.6028/nist.fips.186-5>.

   [KSMW2024] Kraemer, J., Struck, P., and M. Weishaupl, "Binding
              Security of Implicitly-Rejecting KEMs and Application to
              BIKE and HQC", n.d., <https://eprint.iacr.org/2024/1233>.

   [SCHMIEG2024]
              Schmieg, S., "Unbindable Kemmy Schmidt: ML-KEM is neither
              MAL-BIND-K-CT nor MAL-BIND-K-PK", 2024,
              <https://eprint.iacr.org/2024/523.pdf>.

   [SEC1]     "Elliptic Curve Cryptography, Standards for Efficient
              Cryptography Group, ver. 2", 2009,
              <https://secg.org/sec1-v2.pdf>.

   [XWING]    "X-Wing: The Hybrid KEM Youâ€™ve Been Looking For", 2024,
              <https://eprint.iacr.org/2024/039.pdf>.

   [XWING-SPEC]
              Connolly, D., Schwabe, P., and B. Westerbaan, "X-Wing:
              general-purpose hybrid post-quantum KEM", Work in
              Progress, Internet-Draft, draft-connolly-cfrg-xwing-kem-
              07, 3 May 2025, <https://datatracker.ietf.org/doc/html/
              draft-connolly-cfrg-xwing-kem-07>.

Acknowledgments

   [[TODO: writeme]]

Author's Address

   Deirdre Connolly
   SandboxAQ
   Email: durumcrustulum@gmail.com
